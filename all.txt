### **Kernel Boot Process Documentation**  

A minimal, step-by-step explanation of how ProtOS kernel boots from power-on to graphical/text output:

---

### **1. Power-On & Firmware Initialization**

- **BIOS/UEFI** activates hardware, performs POST checks  
- **Boot Device Selection**: BIOS looks for bootable devices in order (HDD, USB, CD, etc.)  
- **Bootloader Loading**: BIOS transfers control to the bootloader (GRUB)  

---

### **2. GRUB Bootloader Phase**

- **Stage 1**: GRUB MBR loads core image  
- **Stage 2**: GRUB reads configuration (`grub.cfg`)  
- **Multiboot2 Header Detection**: GRUB scans kernel binary for header in first 32KB  

```nasm
; Required Multiboot2 Header Structure
section .multiboot_header
    dd 0xE85250D6    ; Magic
    dd 0             ; Architecture (0 = 32-bit)
    dd header_end - header_start
    ; ... (tags follow)
```

- **Framebuffer Initialization**: GRUB sets up video mode per header request  

---

### **3. Kernel Entry & Setup**

- **Control Transfer**: GRUB jumps to kernel entry point (`KInit`)  
- **Basic CPU State**: Protected mode enabled, interrupts disabled  
- **Stack Setup**: Initialize stack pointer for C code  

```c
// Minimal Kernel Entry (kernel.c)
void KInit(uint32_t magic, uint32_t *mb2_info) {
    // 1. Initialize stack
    // 2. Parse Multiboot2 tags
    // 3. Initialize drivers
}
```

---

### **Boot Flow Diagram**  

```
[Power On] â†’ [BIOS/UEFI] â†’ [GRUB] â†’ [Kernel Header Check]  
               â†“                      â†“  
          [Hardware Init]    [Load Kernel to Memory]  
                                  â†“  
                          [Jump to KInit()]  
                                  â†“  
                   [Initialize Drivers] â†’ [Graphics]  
                                  â†“  
                          [Main Kernel Loop]  
```
# Building ProtOS

**ProtOS Build Documentation**  

---

### **Prerequisites**  

### Summon dependencies (Two basic disto's, i use arch btw)

Arch/Manjaro (yay required)

```bash
# Summon compiler dragons (i use arch btw)
yay -S grub nasm gcc binutils qemu-full edk2-ovmf
```

(Didn't tested, but in theory this should work)
Debian/Ubuntu (apt required)

```bash
# For our Debian/Ubuntu friends:
sudo apt install grub-pc nasm gcc binutils qemu-system-x86 ovmf
```

### UEFI

> QEMU testing with UEFI requires OVMF firmware.
> We don't ship it because of the license.
> [EDK2](https://github.com/tianocore/edk2) or `sudo pacman -S edk2-ovmf`
> then copy `OVMF_CODE.fd` to firmware folder.
> And don't forget about permissions.

---

### **Key Components**  

#### **1. Directories**  

- `src/`: Contains all C and assembly (.asm) source files.  
- `headers/`: Header files for the project.  
- `build/`: Output directory for compiled objects and the final kernel.  
- `grub/`: GRUB configuration (`grub.cfg`).  
- `isodir/`: Temporary folder for ISO creation.  
- `firmware/`: Holds UEFI firmware files (e.g., `OVMF_CODE.4m.fd`).  

#### **2. Important Files**  

- `linker.ld`: Linker script (ensures proper kernel layout).  
- `grub.cfg`: GRUB bootloader configuration.  

---

### **Build Process**  

#### **Step 1: Compile Sources**  

- **C Files**: Compiled into `.o` files with `gcc`.  
- **Assembly Files**: Assembled into `.o` files with `nasm`.  

#### **Step 2: Link the Kernel**  

- All `.o` files are linked using `ld` and the `linker.ld` script to create `protos.kernel`.  

#### **Step 3: Create Bootable ISO**  

- The kernel and GRUB files are bundled into `ProtOS.iso` using `grub-mkrescue`.  

---

### **Makefile Commands**  

Run these from the project root:  

| Command         | Action                                                                 |  
|-----------------|-----------------------------------------------------------------------|  
| `make all`      | Compiles the kernel (does not create ISO).                            |  
| `make`          | Same as `make all`.                                                   |  
| `make bios`     | Runs the OS in QEMU using BIOS emulation.                             |  
| `make run`      | Runs the OS in QEMU with UEFI firmware.                               |  
| `make debug`    | Runs with debug options and logs output to `uefi_debug.log`.          |  
| `make release`  | Copies the ISO to the `release/` directory.                           |  
| `make clean`    | Deletes build artifacts (`build/`, `isodir/`, etc.).                  |  

---

### **Example Workflow**  

1. **Build the Kernel and ISO**:  

   ```bash  
   make all   # Compiles the kernel  
   make       # Shortcut for the above  
   ```  

2. **Run in QEMU (UEFI)**:  

   ```bash  
   make run  
   ```  

3. **Run in QEMU (BIOS)**:  

   ```bash  
   make bios  
   ```  
# Serial Output Driver Documentation

## Overview
Provides low-level serial port communication capabilities for kernel debugging and text output. Implements basic COM1 port handling at 9600 baud rate. Designed for integration with QEMU's `-serial stdio` option.

## Features
- 9600 baud rate communication
- Blocking character output
- Automatic CR/LF conversion
- Basic string output
- Early boot debugging support

## API Reference

### 1. `void serial_init(void)`
Initializes COM1 port with standard PC settings.  
**Must be called first** before any output operations.

### 2. `void serial_putc(char c)`
Outputs single character to serial port.  
Handles:
- LF -> CR/LF conversion
- Blocking until port is ready
- ASCII character output

### 3. `void serial_puts(const char *str)`
Outputs null-terminated string.  
Automatically handles:
- Newline conversions
- String length detection
- Sequential character transmission

## Usage Example

```c
// Kernel initialization
KInit(...) {
    serial_init();
    serial_puts("\n\n=== ProtOS Boot Sequence ===\n");
    
    // Mixed debug output
    serial_puts("Initializing memory manager... ");
    init_memory();
    serial_puts("[OK]\n");
    
    // Error handling
    if(!fb) {
        serial_puts("[ERROR] No framebuffer detected!\n");
        while(1);
    }
}
```

## Technical Details

### Port Configuration
| Setting              | Value          |
|----------------------|----------------|
| Base port            | 0x3F8 (COM1)  |
| Baud rate            | 9600           |
| Data bits            | 8              |
| Stop bits            | 1              |
| Parity               | None           |
| FIFO buffer          | 14-byte        |

### Character Handling
| Input | Output    | Description              |
|-------|-----------|--------------------------|
| \n    | \r\n      | Automatic newline fix    |
| \t    | 4 spaces  | Tab expansion            |
| Other | Direct    | ASCII character pass-through |

## Limitations
1. No input handling (read-only implementation)
2. Fixed to COM1 port
3. No baud rate configuration
4. Blocking implementation (no interrupts)
---

> **Note**: This serial implementation is primarily for debugging purposes. For user-facing text output, use the framebuffer-based `KOutput()` function from the text driver.

---
# Text Driver Documentation (`text.c`)

## Overview
Provides framebuffer text rendering capabilities for your kernel using PSF2 fonts. Key features:
- Scaled text rendering (2x by default)
- Customizable colors and spacing
- Cursor positioning
- Basic text formatting (newlines, tabs)
- Automatic word wrapping

## Dependencies
- Graphic framebuffer driver (`graphic.c`)
- PSF2 font file compiled into kernel
- Multiboot2 framebuffer initialization

---

## API Reference

### 1. `void init_font(void)`

Initializes the font system using embedded PSF2 font data.  
**Must be called after** framebuffer initialization.

### 2. `void KOutput(const char *str)`

**Primary text output function** - Renders a null-terminated string.  
Supports:

- `\n` Newlines
- `\t` Tabs (4 character width)
- Automatic word wrapping

### 3. `void set_text_color(uint32_t fg, uint32_t bg)`

Sets foreground and background colors.  
Parameters:

- `fg`: Foreground color (24-bit RGB)
- `bg`: Background color (24-bit RGB)

### 4. `void set_cursor_pos(uint32_t x, uint32_t y)`

Sets text cursor position in **character grid coordinates**  
Example: `set_cursor_pos(2, 3)` = Column 3, Row 4

### 5. Configuration Variables

```c
extern uint32_t font_scale;    // Rendering scale (1-4)
extern uint32_t line_spacing;  // Pixels between lines
extern uint32_t char_spacing;  // Pixels between characters
```

---

## Usage Example

```c
// Kernel initialization
KInit(...) {
    graphics_init(fb_tag);
    init_font();
    
    // Configure output
    set_text_color(0x00FF00, 0x000033); // Green on dark blue
    font_scale = 2; // Double-size text
    line_spacing = 4;

    // Display output
    KOutput("ProtOS Kernel v0.1.8\n");
    KOutput("Memory: 4GB\tStatus: OK\n");
    KOutput("UEFI Firmware: ");
    KOutput(firmware_version);
}
```

---

## Technical Details

### Font Requirements

- **Format**: PSF2 (Magic: `0x72 0xb5 0x4a 0x86`)
- **Recommended Size**: 8x16 or 16x32 pixels
- **Placement**: Compiled into kernel using objcopy

### Memory Layout

```
+-------------------+
| PSF2 Header       | 32 bytes
+-------------------+
| Glyph Data        | (num_glyphs * bytes_per_glyph)
+-------------------+
```

### Character Rendering

- Each character drawn as scaled bitmap
- Background pixels explicitly filled
- Pixel-perfect scaling with anti-aliasing

---

## Advanced Usage

### Debug Output

```c
// Combine with serial output
KOutput("Initializing devices...");
serial_puts("DEVICE INIT: Starting hardware detection\n");

// Error handling
if(!fb) {
    KOutput("FATAL: No framebuffer!");
    serial_puts("[ERROR] Framebuffer not found\n");
    while(1);
}
```

### Dynamic Configuration

```c
// Adjust for high-resolution displays
if(fb->framebuffer_width > 1920) {
    font_scale = 3;
    line_spacing = 6;
    char_spacing = 2;
}
```

---

## Performance Considerations

1. **Batch Operations**: Group `KOutput` calls
2. **Pre-Render Static Text**: During initialization
3. **Limit Redraws**: Update only changed regions
4. **Use Serial for Logging**: Less overhead than framebuffer

---

## Known Limitations

1. No UTF-8/Unicode support
2. Fixed tab size (4 characters)
3. No text scrolling implementation
4. Single font active at a time
# Framebuffer Graphics Library

Simple drawing functions for a linear framebuffer in 32-bit RGB mode.

## Core Functions

### `graphics_init(fb_tag)`

- Initialize the graphics system
- **Parameters**:
  - `fb_tag`: Valid Multiboot2 framebuffer tag
- **Must be called first** before any drawing operations

### `draw_pixel(x, y, color)`

- Draw a single pixel
- **Parameters**:
  - `x`, `y`: Screen coordinates (0,0 = top-left)
  - `color`: 24-bit RGB color (0xRRGGBB)

### `clear_screen(color)`

- Fill entire screen with a color
- **Parameters**:
  - `color`: 24-bit RGB fill color

### `draw_rect(x, y, w, h, color, filled)`

- Draw a rectangle
- **Parameters**:
  - `x`, `y`: Top-left position
  - `w`, `h`: Width and height
  - `color`: 24-bit RGB color
  - `filled`: 0=outline, 1=filled

### `draw_line(x0, y0, x1, y1, color, thickness)`

- Draw a straight line using Bresenham's algorithm
- **Parameters**:
  - Start (`x0`,`y0`) and end (`x1`,`y1`) points
  - `color`: 24-bit RGB color
  - thickness: unsigned integer. Thickness = parameter \ 2. Example: if thickness = 10 it will be +5 pixel on both sides of the line.

## Color Format

- Colors are specified as 24-bit RGB values
- Example: `0xFF0000` = red, `0x00FF00` = green, `0x0000FF` = blue
- Actual displayed color depends on framebuffer configuration
# Multiboot2 Framebuffer Support

## Key Structures

### `struct multiboot_tag_framebuffer`

Contains framebuffer configuration:

- Physical address
- Resolution (width/height)
- Color depth (bpp)
- Pitch (bytes per scanline)
- Color mask information

## Helper Function

### `mb2_get_fb_tag(info)`

- Find framebuffer tag in Multiboot2 info
- **Parameters**:
  - `info`: Pointer to Multiboot2 info structure
- **Returns**: Framebuffer tag pointer or NULL

## Usage Flow

1. Get Multiboot2 info from bootloader
2. Use `mb2_get_fb_tag()` to find framebuffer
3. Verify framebuffer is in direct RGB mode
4. Pass to `graphics_init()`
# Getting Started

## Basic Setup

```c
struct multiboot_tag_framebuffer *fb = mb2_get_fb_tag(mb2_info);
if(fb && fb->framebuffer_type == FB_TYPE_DIRECTRGB) {
    graphics_init(fb);
}
```

## Drawing Example

```c
// Draw red diagonal line
draw_line(0, 0, 
          fb->framebuffer_width-1, fb->framebuffer_height-1,
          0xFF0000);

// Draw blue filled rectangle
draw_rect(100, 100, 200, 150, 0x0000FF, 1);

// Clear to green
clear_screen(0x00FF00);
```

## Important Notes

Coordinates start at top-left corner
Only works with 32-bit direct RGB framebuffers
No bounds checking on purpose - draw within screen limits
Not thread-safe - assume single caller
<p align="center">
  <img src="https://github.com/user-attachments/assets/e597ff5e-c87b-4fc6-ba28-3a1fcadbf761" alt="ProtOS Logo" width="1920">
</p>

<h3 align="center">ğŸ›  Rethink the Wheel | ğŸ¾ Paws-on Development | ğŸ”µ Blueprint for Modern Computing</h3>

<div align="center">
  
  [![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
  ![GitHub commit activity](https://img.shields.io/github/commit-activity/m/GasFurr/ProtOS)
  ![Version](https://img.shields.io/badge/Version-0.1.9--alpha-red)
  [![Build](https://img.shields.io/badge/Build-Passing-brightgreen)](https://github.com/GasFurr/ProtOS/actions)

</div>

---

> **âš ï¸ Dragon Warning**  
> ProtOS is currently in its embryonic stage. Expect broken code, sudden rewrites, and occasional tears. Not suitable for production (or sanity).

## ğŸš€ Philosophy in Three Acts

<div align="center">

**âš¡ Fast & Fresh**

*Modern hardware deserves modern software - no legacy baggage allowed*

**ğŸ§© Modular by Design**

*Just snap components together, all in one system configuration file.*

**ğŸ”­ Future-First**

*Why walk when you can teleport? No legacy baggage, robust GRUB-powered foundation*

</div>

---

## ğŸ“¦ Project Anatomy

```bash
ProtOS/
â”œâ”€â”€ build/          # Compiled objects
â”œâ”€â”€ docs/           # Documentation womb
â”œâ”€â”€ grub/           # Bootloader configs
â”œâ”€â”€ headers/        # C headers party
â”œâ”€â”€ src/            # Kernel guts
â”‚   â”œâ”€â”€ boot/       # Boot sequence acrobatics
â”‚   â”œâ”€â”€ drivers/    # Hardware whisperers
â”‚   â””â”€â”€ kernel/     # Core brain surgery
â””â”€â”€ tools/          # Build-time gadgets
```

## ğŸ› ï¸ Building the Beast

### Summon dependencies (choose your distro flavor)

<details>
<summary>Arch/Manjaro (yay required)</summary>

```bash
# Summon compiler dragons (i use arch btw)
yay -S grub nasm gcc binutils qemu-full edk2-ovmf
```

</details>

<details>
<summary>Debian/Ubuntu (apt required)</summary>

```bash
# For our Debian/Ubuntu friends:
sudo apt install grub-pc nasm gcc binutils qemu-system-x86 ovmf
```

</details>

```bash
# Clone with surgical precision
git clone https://github.com/GasFurr/ProtOS.git

# Summon the build spirits
make all

# For brave souls only:
make run

# To bring tears
make debug

# To just build the iso
make release 
```

---

> **ğŸ‰ Dragon's Note**  
> QEMU testing requires OVMF firmware. We don't ship it for the same reason
> dragons don't share gold: Lawyers. Get yours from
> [EDK2](https://github.com/tianocore/edk2) or `sudo pacman -S edk2-ovmf`
> then copy `OVMF_CODE.fd` to firmware folder. No hoard, no boot!

---

## ğŸ“‹ Progress Report (Survival Mode)

| Task                          | Status    | Notes                |
|-------------------------------|-----------|----------------------|
| boot.asm                      | ğŸš§ 80%    | Assembler yoga       |
| Basic makefile                | âœ… 100%   | Builds without fire  |
| grub.cfg                      | âœ… 100%   | Bootloader ready     |
| MB2 tags header               | ğŸš§ 40%    | Multiboot mysteries  |
| IDT & GDT                     | ğŸš« 0%     | CPU gatekeeping      |
| Graphics/text mode drivers    | ğŸš§ 80%    | Pixel uwusability    |
| Keyboard interwupts           | ğŸš« 0%     | Keypress archaeology |
| Time drivers                  | ğŸš« 0%     | Chronomancy          |
| bschell                       | ğŸš« 0%     | Terminal therapy     |
| Branding                      | âœ… 100%   | No longer disgusting |

---

## ğŸ’¥ ALPHA 0.1.9.1 CHANGELOG

  Just works. Little patch

### ğŸš€ New features

- Better logging.
- 64KB stack

### âš¡ Optimization

- No changes

### ğŸ”§ Fixed

- make debug just not worked.
- Now it works.

### ğŸ“ Documentation

- No changes

### ğŸ‰ Known issues

- No changes

---

## ğŸ”® Crystal Ball (Roadmap)

- **Phase 1**: Make computer go beep (hardware communication)
- **Phase 2**: Pretend we're UNIX (basic shell operations)
- **Phase 3**: ??? (profit)

---

## ğŸ“œ License to Tinker

MIT Licensed - Do whatever you want, but maybe mention us if it blows up.  
*"Rethink the Wheel"* isn't just a slogan - it's a way of life (and possibly yarn).

<p align="left">
  <img src="https://github.com/user-attachments/assets/77f70569-2c2f-444d-b800-6cd5005d2e5d" alt="ProtOS Logo" width="600">
</p>

---

<div align="center">
  
## ğŸ“¬ Contact

Got questions, suggestions, or dragon taming tips?  
ğŸ“§ [gasfurri@gmail.com](mailto:gasfurri@gmail.com)
  
  ![GitHub last commit](https://img.shields.io/github/last-commit/GasFurr/ProtOS?color=blue)

</div>

---

```asciiart
 /\_/\  
( o.o ) 
 > ^ <  /* Compiles with love */
```

"UNIX is user-friendly. Itâ€™s just selective about who its friends are"
(carved on a kernel developer's tombstone)
/* Linker file */
ENTRY(KInit)

PHDRS {
    headers PT_LOAD FLAGS(5);  /* R-X for multiboot header */
    text PT_LOAD FLAGS(5);     /* R-X */
    rodata PT_LOAD FLAGS(4);   /* R-- */
    data PT_LOAD FLAGS(6);     /* RW- */
}

SECTIONS {
    . = 1M;

    /* Multiboot header must be first */
    .multiboot_header : ALIGN(4K) {
        *(.multiboot_header)
    } :headers

    .text : ALIGN(4K) {
        *(.text .text.*)
    } :text

    .rodata : ALIGN(4K) {
        *(.rodata .rodata.*)
        . = ALIGN(4K);
        *(.font)  /* PSF2 font data */
    } :rodata

    .data : ALIGN(4K) {
        *(.data .data.*)
    } :data

    .bss : ALIGN(4K) {
        *(COMMON)
        *(.bss .bss.*)
    } :data

    /DISCARD/ : {
        *(.eh_frame)
        *(.note.*)
        *(.comment)
    }
}
; \
;  >- Boot file. Where everything starts. 
; /
;
; First things first - multiboot2 header.

section .multiboot_header

header_start:
;   Magic number:
dd 0xE85250D6
;   Architecture:
dd 0 ; i386 or 32-bit protected mode.
;   Header length:
dd header_end - header_start
;   Checksum: -(magic + architecture + header_length)
dd 0x100000000 - (0xE85250D6 + 0 + (header_end - header_start))

;   Information request tag:
align 8
;   Type 1: Information request
dw 1
;   Flags
dw 0
;   Size = 24 (8 header + 3*4 + 4 padding)
dd 24
;   Request command line
dd 1
;   Request bootloader name
dd 2
;   Request memory map
dd 6
;   Padding:
dd 0

;   Framebuffer request tag:
align 8
;   Type 5: Framebuffer
dw 5
;   Flags
dw 0x1
;   Size 20 bytes (8 header + 3*4)
dd 20
;   Width: 0 - Just let GRUB choose.
dd 1920
;   Height:
dd 1080
;   Depth: 32 bits per pixel
dd 32

;   Kernel entry point tag:
align 8
;   Type 3: Entry adress
dw 3
;   Flags
dw 0
;   Size: 16 bytes
dd 16
;   Entry point
dd _start 
;   Padding
dd 0

;   End tag:
align 8
;   Type 0: End.
dw 0
;   Flags
dw 0
;   Size
dd 8
header_end:

section .text


extern KInit
global _start
_start:
;   Setting up stack.
  mov esp, stack_top
;   Pass Multiboot2 info pointer as argument (EBX holds the adress)
  push ebx
;   Pass Multiboot2 Magic Number
  push eax
;   Calling C kernel entry point.
  call KInit
;   If kernel_entry returns (should'nt happen) - hang.
  cli

.haltncatchfire:
  hlt
  jmp .haltncatchfire

global gdt_flush
extern gdtp
gdt_flush:
    lgdt [gdtp]
    jmp 0x08:.reload_cs  ; Far jump to reload CS
.reload_cs:
    mov ax, 0x10         ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    ret

section .bss
align 16
stack_bottom:
  resb 16384 ; 16KB stack.
stack_top:
#include "gdt.h"
#include "serial.h"

struct gdt_entry gdt[3] = {0};
struct gdt_ptr gdtp = {0};

void gdt_init() {
  gdtp.limit = sizeof(gdt) - 1;
  gdtp.base = (uint32_t)&gdt;

  // Null descriptor
  gdt_set_entry(0, 0, 0, 0, 0);

  // Code segment - 0x9A (10011010)
  gdt_set_entry(1, 0, 0xFFFFF, // 4GB limit with 4K granularity
                0x9A,          // Present, Ring 0, Code, Exec/Read
                0xCF);         // 4K granular, 32-bit mode

  // Data segment - 0x92 (10010010)
  gdt_set_entry(2, 0, 0xFFFFF,
                0x92, // Present, Ring 0, Data, Read/Write
                0xCF);

  gdt_flush((uint32_t)&gdtp);
}

// Atomic descriptor creation
void gdt_set_entry(int num, uint32_t base, uint32_t limit, uint8_t access,
                   uint8_t gran) {
  gdt[num].base_low = (base & 0xFFFF);
  gdt[num].base_middle = (base >> 16) & 0xFF;
  gdt[num].base_high = (base >> 24) & 0xFF;

  gdt[num].limit_low = (limit & 0xFFFF);
  // Fix granularity calculation
  gdt[num].granularity = (gran & 0xF0) | ((limit >> 16) & 0x0F);

  gdt[num].access = access;
}

void gdt_debug() {
  serial_puts("\n=== GDT Validation ===\n");

  // Check null descriptor
  if (gdt[0].limit_low != 0 || gdt[0].base_low != 0) {
    serial_puts("NULL DESCRIPTOR CORRUPT!\n");
    return;
  }

  // Code segment validation
  uint8_t code_access = gdt[1].access;
  serial_puts("Code Segment: ");
  serial_puthex(code_access);
  // Mask off Accessed bit (bit 0) and check against 0x9A
  serial_puts(((code_access & 0xFE) == 0x9A) ? " (VALID)\n" : " (INVALID!)\n");

  // Data segment validation
  uint8_t data_access = gdt[2].access;
  serial_puts("Data Segment: ");
  serial_puthex(data_access);
  // Mask off Accessed bit (bit 0) and check against 0x92
  serial_puts(((data_access & 0xFE) == 0x92)
                  ? " (VALID)\n"
                  : " (INVALID!)\n"); // Check GDTR loading

  asm volatile("sgdt %0" : "=m"(gdtp));
  serial_puts("GDTR Loaded: ");
  serial_puthex(gdtp.base);
  serial_puts(" Limit: ");
  serial_puthex(gdtp.limit);
  serial_puts("\n");

  // In gdt_debug()
  serial_puts("Raw Code Entry: ");
  for (int i = 0; i < 8; i++) {
    serial_puthex(*((uint8_t *)&gdt[1] + i));
    serial_putc(' ');
  }
  serial_puts("\n");
}
// graphics.c - Optimized Framebuffer Graphics
#include "graphic.h"
#include "mb2tags.h"
#include "serial.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// Internal state
struct multiboot_tag_framebuffer *fb = NULL;
uint32_t *fb_mem = NULL;
uint32_t fb_pitch = 0;

// Fast absolute value
#define iabs(x) ((x) < 0 ? -(x) : (x))

/**
 * Precompute native color format
 * @param rgb 24-bit color in 0xRRGGBB format
 * @return Native color format, 0 if unsupported mode
 */
static inline uint32_t convert_color(uint32_t rgb) {
  // Compile-time constant mask calculations
  const uint32_t r = (rgb >> 16) & 0xFF;
  const uint32_t g = (rgb >> 8) & 0xFF;
  const uint32_t b = rgb & 0xFF;
  return 0xFF000000 | (r << 16) | (g << 8) | b;
}

/**
 * Initialize graphics subsystem
 */
void graphics_init(struct multiboot_tag_framebuffer *fb_tag) {
  if (!fb_tag || fb_tag->framebuffer_type != FB_TYPE_DIRECTRGB)
    return;

  fb = fb_tag;
  fb_mem = (uint32_t *)(uintptr_t)fb->framebuffer_addr;
  fb_pitch = fb->framebuffer_pitch / sizeof(uint32_t);
  serial_puts("Graphics initialized!\n");
}

/**
 * Bulk pixel writer (aligned 32-bit writes)
 */
static inline void bulk_write(uint32_t *dest, uint32_t color, size_t count) {
  while (count--)
    *dest++ = color;
}

void draw_pixel(uint32_t x, uint32_t y, uint32_t color) {
  if (!fb || x >= fb->framebuffer_width || y >= fb->framebuffer_height)
    return;

  // Calculate pixel position
  uint8_t *pixel = (uint8_t *)(uintptr_t)fb->framebuffer_addr +
                   y * fb->framebuffer_pitch + x * (fb->framebuffer_bpp / 8);

  // Write color value
  *(uint32_t *)pixel = convert_color(color);
}

/**
 * Optimized screen clear
 */
void clear_screen(uint32_t color) {
  if (!fb)
    return;

  const uint32_t native = convert_color(color);
  const size_t stride = fb_pitch;
  const size_t total = fb->framebuffer_height * stride;

  // Fill memory in large chunks
  for (size_t i = 0; i < total; i += stride) {
    bulk_write(fb_mem + i, native, fb->framebuffer_width);
  }
}

/**
 * Fast rectangle drawing
 */
void draw_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color,
               int filled) {
  if (!fb || x >= fb->framebuffer_width || y >= fb->framebuffer_height)
    return;

  // Precompute native color once
  const uint32_t native = convert_color(color);
  const uint32_t max_x =
      (x + w) < fb->framebuffer_width ? x + w : fb->framebuffer_width;
  const uint32_t max_y =
      (y + h) < fb->framebuffer_height ? y + h : fb->framebuffer_height;

  if (filled) {
    // Optimized filled rectangle
    for (uint32_t cy = y; cy < max_y; cy++) {
      uint32_t *line = fb_mem + cy * fb_pitch + x;
      bulk_write(line, native, max_x - x);
    }
  } else {
    // Optimized outline using horizontal lines
    bulk_write(fb_mem + y * fb_pitch + x, native, max_x - x); // Top
    bulk_write(fb_mem + (max_y - 1) * fb_pitch + x, native,
               max_x - x); // Bottom

    // Vertical lines
    for (uint32_t cy = y; cy < max_y; cy++) {
      fb_mem[cy * fb_pitch + x] = native;           // Left
      fb_mem[cy * fb_pitch + (max_x - 1)] = native; // Right
    }
  }
  serial_puts("Rectangle drawn\n");
}

/**
 * Draw line using Bresenham's algorithm with proper thickness
 * @param x0 Start X
 * @param y0 Start Y
 * @param x1 End X
 * @param y1 End Y
 * @param color 24-bit RGB color
 * @param thickness Line thickness in pixels (minimum 1)
 */
void draw_line(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t color,
               int thickness) {
  if (!fb || thickness < 1)
    return;

  const uint32_t native = convert_color(color);
  const bool steep = iabs(y1 - y0) > iabs(x1 - x0);
  int32_t dx = iabs(x1 - x0);
  int32_t dy = iabs(y1 - y0);
  int32_t err = dx - dy;
  int32_t sx = x0 < x1 ? 1 : -1;
  int32_t sy = y0 < y1 ? 1 : -1;

  // Proper thickness calculation for both even/odd values
  const int t_half = thickness / 2;
  const int t_start = -t_half;
  const int t_end = t_half + (thickness % 2) - 1;

  while (1) {
    // Draw thickness perpendicular to line direction
    for (int t = t_start; t <= t_end; t++) {
      int32_t px, py;

      if (steep) {
        // Vertical line - spread horizontally
        px = x0 + t;
        py = y0;
      } else {
        // Horizontal line - spread vertically
        px = x0;
        py = y0 + t;
      }

      // Boundary checks
      if (px >= 0 && (uint32_t)px < fb->framebuffer_width && py >= 0 &&
          (uint32_t)py < fb->framebuffer_height) {
        fb_mem[py * fb_pitch + px] = native;
      }
    }

    if (x0 == x1 && y0 == y1)
      break;

    int32_t e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x0 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y0 += sy;
    }
  }
  serial_puts("Line drawn\n");
}
// Multiboot tags parsing driver.
// serial.c - Serial port implementation
#include "serial.h"
#include <stddef.h>
#include <stdint.h>

#define COM1_PORT 0x3F8

static void outb(unsigned short port, unsigned char val) {
  asm volatile("outb %0, %1" : : "a"(val), "Nd"(port));
}

static unsigned char inb(unsigned short port) {
  unsigned char ret;
  asm volatile("inb %1, %0" : "=a"(ret) : "Nd"(port));
  return ret;
}

void serial_init() {
  outb(COM1_PORT + 1, 0x00); // Disable interrupts
  outb(COM1_PORT + 3, 0x80); // Enable DLAB (set baud rate divisor)
  outb(COM1_PORT + 0, 0x0C); // Set divisor to 12 (9600 baud)
  outb(COM1_PORT + 1, 0x00);
  outb(COM1_PORT + 3, 0x03); // 8 bits, no parity, one stop bit
  outb(COM1_PORT + 2, 0xC7); // Enable FIFO, clear them, 14-byte threshold
  serial_puts("Serial Output initialized.");
}

void serial_putc(char c) {
  while ((inb(COM1_PORT + 5) & 0x20) == 0)
    ; // Wait for transmit buffer empty
  outb(COM1_PORT, c);

  // Add CR when we get LF
  if (c == '\n') {
    serial_putc('\r');
  }
}

void serial_puthex(uint32_t val) {
  const char *hex_chars = "0123456789ABCDEF";

  // Prefix
  serial_puts("0x");

  // Process each nibble from MSB to LSB
  for (int i = 28; i >= 0; i -= 4) {
    uint8_t nibble = (val >> i) & 0xF;
    serial_putc(hex_chars[nibble]);
  }
}

void serial_puts(const char *str) {
  for (size_t i = 0; str[i]; i++) {
    serial_putc(str[i]);
  }
}
// text.c
#include "text.h"
#include "font.h" // Contains PSF2 header
#include "graphic.h"
#include "mb2tags.h"
#include "serial.h"
#include <stddef.h>

static uint32_t text_color = 0xFFFFFF;
static uint32_t bg_color = 0x000000;
static uint32_t cursor_x = 0;
static uint32_t cursor_y = 0;
uint32_t char_width = 8;
uint32_t char_height = 16;
uint32_t font_scale = 2;
uint32_t char_spacing = 2;
uint32_t line_spacing = 2;

static const struct psf2_header *font_header;
static const uint8_t *font_glyphs;

static int memcmp(const void *s1, const void *s2, size_t n) {
  const unsigned char *p1 = s1, *p2 = s2;
  for (size_t i = 0; i < n; i++) {
    if (p1[i] != p2[i])
      return p1[i] - p2[i];
  }
  return 0;
}

void init_font(void) {
  font_header = (const struct psf2_header *)&_binary_font_psf_start;

  // Manually check PSF2 magic: 0x72 0xb5 0x4a 0x86
  const uint8_t expected_magic[4] = {0x72, 0xb5, 0x4a, 0x86};
  uint8_t actual_magic[4];

  // Manually copy first 4 bytes
  for (int i = 0; i < 4; i++) {
    actual_magic[i] = ((const uint8_t *)font_header)[i];
  }

  if (memcmp(actual_magic, expected_magic, 4) != 0) {
    draw_rect(0, 0, 20, 20, 0xFF0000, 1); // Red error
    return;
  }

  char_width = font_header->width;
  char_height = font_header->height;
  font_glyphs = (const uint8_t *)font_header + font_header->headersize;

  serial_puts("Font initialized!\n");
  // draw_rect(150, 0, 20, 20, 0x00FF00, 1); // Green success
}

void set_text_color(uint32_t fg, uint32_t bg) {
  text_color = fg;
  bg_color = bg;
}

void set_cursor_pos(uint32_t x, uint32_t y) {
  cursor_x = x * char_width * font_scale;  // Add scaling
  cursor_y = y * char_height * font_scale; // Add scaling
}

// Add missing advance_cursor function
static void advance_cursor(void) {
  cursor_x += char_width * font_scale;

  // Check against scaled width
  if (cursor_x + (char_width * font_scale) > fb->framebuffer_width) {
    cursor_x = 0;
    cursor_y += char_height * font_scale; // Scaled line height
  }
}

void draw_char(unsigned char c) {
  if (c < 32 || c > 127)
    return;

  // Calculate glyph offset using PSF2 header data
  const uint8_t *glyph = font_glyphs + (c * font_header->bytes_per_glyph);

  // Calculate bytes per row (ceil(width/8))
  const uint32_t bytes_per_row = (font_header->width + 7) / 8;

  for (uint32_t y = 0; y < font_header->height; y++) {
    for (uint32_t byte = 0; byte < bytes_per_row; byte++) {
      uint8_t glyph_byte = glyph[y * bytes_per_row + byte];

      for (uint32_t bit = 0; bit < 8; bit++) {
        uint32_t x = byte * 8 + bit;
        if (x >= font_header->width)
          break;

        if (glyph_byte & (0x80 >> bit)) {
          // Draw scaled pixel
          for (uint32_t sy = 0; sy < font_scale; sy++) {
            for (uint32_t sx = 0; sx < font_scale; sx++) {
              draw_pixel(cursor_x + x * font_scale + sx,
                         cursor_y + y * font_scale + sy, text_color);
            }
          }
        }
      }
    }
  }
  cursor_x += char_spacing * font_scale;
  advance_cursor();
}

void KOutput(const char *str) {
  for (size_t i = 0; str[i]; i++) {
    if (str[i] == '\n') {
      cursor_x = 0;
      cursor_y += (char_height + line_spacing) * font_scale;
    } else if (str[i] == '\t') {
      cursor_x += (char_width + char_spacing) * font_scale * 4;
    } else {
      draw_char(str[i]);
    }

    // Simple word wrap
    if (cursor_x + (char_width * font_scale) > fb->framebuffer_width) {
      cursor_x = 0;
      cursor_y += (char_height + line_spacing) * font_scale;
    }
  }
  serial_puts("Text output success!\n");
}
// Time driver. It will give OS some functions to understand the time.
//
// Kernel initialization.
//
#include "gdt.h"
#include "graphic.h"
#include "kernel.h"
#include "mb2tags.h"
#include "serial.h"
#include "text.h"

void test_gdt_protection() {
  // First validate GDT works for normal access
  volatile uint32_t *valid_ptr = (uint32_t *)0x00100000;
  *valid_ptr = 0xDEADBEEF;

  // Then test invalid execution
  void (*bad_jump)() = (void (*)())valid_ptr;
  serial_puts("Testing GDT protection...\n");
  bad_jump(); // Should trigger GPF

  // This should never be reached if protection works
  serial_puts("GDT PROTECTION FAILED!\n");
}

void KInit(uint32_t magic, uint32_t *mb2_info) {
  (void)magic;
  gdt_init();
  asm volatile("" ::: "memory");
  serial_init();
  gdt_debug();
  test_gdt_protection();
  struct multiboot_tag_framebuffer *fb_tag = mb2_get_fb_tag(mb2_info);
  if (!fb_tag) {
    // Draw fatal error pattern
    for (uint32_t y = 0; y < 50; y++)
      for (uint32_t x = 0; x < 50; x++)
        draw_pixel(x, y, 0xFF0000);
    serial_puts("FATAL MULTIBOOT ERROR\n");
    while (1)
      ;
  }
  serial_puts("Multiboot tags parsed\n");
  graphics_init(fb_tag);
  clear_screen(BLACK); // black background
  init_font();

  set_cursor_pos(0, 0);
  set_text_color(PROTOS_BLUE, BLACK);
  KOutput("GDT Loaded: ");
  KOutput(gdt[1].access == 0x9A ? "VALID" : "CORRUPT\n");
  KOutput("Testing GDT PROTECTION \n");
  /*
  KOutput("Test pattern:");
  // Basic framebuffer test
  // Test pattern
  draw_rect(100, 40, 100, 100, RED, 1);   // Red
  draw_rect(210, 40, 100, 100, GREEN, 1); // Green
  draw_rect(320, 40, 100, 100, BLUE, 1);  // Blue
  draw_rect(430, 40, 100, 100, WHITE, 1); // White
  // Protos-Blue line
  draw_line(0, 155, fb_tag->framebuffer_width - 1, 155, PROTOS_BLUE, 10);

  set_cursor_pos(0, 5);
  KOutput(" ProtOS-Alpha 0.1.9\n");
  KOutput(" Initialization Finished!\n");
  serial_puts(" ProtOS-Alpha 0.1.9");
  */
  serial_puts("Calling KMain... \n ------ \n");
  KMain();

  hcf();
}
#include "graphic.h"
#include "kernel.h"
#include "serial.h"
#include "text.h"
#include <gdt.h>
#include <stddef.h>
#include <stdint.h>

void KMain() {
  // init.c should call function KMain:
  serial_puts("\nProtOS Main Kernel started.\n");
  // Clearing screen and setting up cursor.
  // Well, its all just tests, "do everything initialized?"
  clear_screen(BLACK);
  set_cursor_pos(1, 0);
  // And then text output;
  KOutput("\tMain kernel started.\n");

  // Halt and catch fire.
  hcf();
}
